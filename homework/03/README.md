## Homework 03

Порядок выполнения этого домашнего задания в целом будет выглядеть так:
 - Обновить локальный репозиторий (не удаляя мертвые в `origin` ветки);
 - Перейти в ветку `hw03`
 - Сделать домашнее задание
 - Открыть pull-request в нужную ветку (какая ветка нужная ты должен выяснить в домашнем задании)
 - Призвать меня сделать review

#### Работа с GIT

 1. Исследуй комманду `git log`, почитай про нее в документации git, посмотри какие форматы вывода есть у нее, и напиши алиас для лога, который будет самый удобный для тебя.
 >_Ответ:_ 1) git log – Показывает все предыдущие коммиты. 2) Документация: https://git-scm.com/docs/git-log 3) alias git_log="git log --pretty=format:'%h - %an, %ar : %s'" 4) alias git_tree="git log --pretty=format:'%h : %an - %s' --graph" P.S.) На русском: https://git-scm.com/book/ru/v1/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%9F%D1%80%D0%BE%D1%81%D0%BC%D0%BE%D1%82%D1%80-%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D0%B8-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82%D0%BE%D0%B2


 2. Посмотри на историю ветки `hw03` - что ты можешь о ней сказать? Можешь ли ты по коммитам восстановить картину происходящего. Можешь ли ты нарисовать гитовый граф коммитов для ветки `hw03`

 >_Ответ:_ 1) git log hw03 – базовая команда. 2) Списокм: git log hw03 --pretty=format:'%h - %an, %ar : %s' 3) Деревом: git log hw03 --pretty=format:'%h : %an - %s' --graph 4) Главное, что я понял – не важно какую ветку смотришь. Если единый мастер на одном ориджине, то у всех веток будет общий коернь.

 3. По результатам этого исследования - в какую ветку в конечном счете нужно открыть пулл-реквест из ветки `hw03`
 >_Ответ:_ 1) в 'calc'


#### Python

 1. Перепиши функцию `modules.string.split_all_by` так чтобы она не была рекурсивной (т.е. не вызывала бы сама себя)
 >_Ответ:_ Похоже что нужно внутри вызывать только `split_by_first`

 2. Напиши следующие две функции

```python

def chunk(lst, size):
    """ 
        Принимает список - lst и целое число - size
        Возвращает список списков длиной в size, заполненных данными из списка lst
        Пример смотри ниже
    """
    pass

def interpolate(string, data = {}):
    """
        Это функция просто шаблонизирует данные из словаря data в строку string
        в таком же формате, как и метод .format строк. 
        Т.е. заменяет все вхождения в строку string вида {ключ}
        на значение одноименного ключа в data
        Если такого ключа нет - то замены не происходит
        Примеры смотри ниже
    """
    pass

chunk(list(range(10)), 2)
# [[0, 1], [2, 3], [4, 5], [5, 6], [7, 8], [9]]

chunk(list(range(10)), 3)
# [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]]

chunk(list(range(10)), 7)
# [[0, 1, 2, 3, 4, 5, 6], [7, 8, 9]]


interpolate('{a} {b}', {
    'a': 'Hello',
    'b': 'World'
}) # вернет строку 'Hello World'

interpolate('{one} + {two} = 3', {
    'one': '1',
    'two': '2'
}) # вернет строку '1 + 2 = 3'

interpolate('Nothing: {abc}', {'x': 'y'})
# вернет строку 'Nothing {abc}'
```

#### Инфраструктура для тестирования

Нужно написать класс `Suite`:
 - Это базовый класс для юнит тестирования, инкапсулиирующий в себя логику с названием блока-тесткейсов.
 - Определять юнит тесты нужно будет так: 

```python
from modules.tester import Suite

class ListTests(Suite):
    def shuffle_test(self):
        # тест-кейсы
        pass
```

 - Сами тесты запускаются следующим образом:
```python
from modules.lists.test import ListTests

list_test = ListTests()
list_test.run()
```