# 08

## HTTP Сервер


> Запуск сервера:
> 1) python app/__init__.py
> 2) открыть в браузере – http://127.0.0.1:8080/


Нужно реализовать следующую фичу для сервера: 

При получении GET запроса по пути `/pkgs/`, сервер должен считывать содержимое дирректории pkgs и показать ответить браузеру отформатированным списком всех пакетов в `pkgs`. Т.е. в нашем случае это будет что-то вроде: 

```html
<h2>Список пакетов:</h2>
<ul>
    <li>calc</li>
    <li>func</li>
    <li>lists</li>
    <li>strings</li>
    <li>tester</li>
</ul>
```

<b>* Задание со звездочкой: показывать рядом с именем пакета еще и количество модулей внутри пакета (исключая __init__.py)</b>

## Что нужно прочитать, чтобы выполнить это задание

Общее: 
 1. [Про работу с операционной системой в Python](https://docs.python.org/2/library/os.html)
 2. [Про работу с файловой системой в Python](https://docs.python.org/3/library/filesys.html)

Конкретное:
 1. [os.listdit](https://docs.python.org/2/library/os.html#os.listdir) или [os.walk](https://docs.python.org/3/library/os.html#os.walk)
 2. [Короткий мануал по работе с файлами в Python](https://www.saltycrane.com/blog/2008/04/working-with-files-and-directories-in/)

### Почитать и ответить на вопросы

 1. Про типы HTTP запросов (GET/POST/PATH/...)

    Memo:
    - METHOD URI HTTP/VERSION,где METHOD — это как раз метод HTTP-запроса, URI — идентификатор ресурса, VERSION — версия протокола (на данный момент актуальна версия 1.1).

    - Заголовки — это набор пар имя-значение, разделенных двоеточием. В заголовках передается различная служебная информация: кодировка сообщения, название и версия браузера, адрес, с которого пришел клиент (Referrer) и так далее.

    - Тело сообщения — это, собственно, передаваемые данные. В ответе передаваемыми данными, как правило, является html-страница, которую запросил браузер, а в запросе, например, в теле сообщения передается содержимое файлов, загружаемых на сервер. Но как правило, тело сообщения в запросе вообще отсутствует.

    Запрос:
    ```
    GET /index.php HTTP/1.1
    Host: example.com
    User-Agent: Mozilla/5.0 (X11; U; Linux i686; ru; rv:1.9b5) 
    Gecko/2008050509     Firefox/3.0b5
    Accept: text/html
    Connection: close

    Первая строка — это строка запроса, остальные — заголовки; тело 
    сообщения отсутствует
    ```

    Ответ:
    ```
    HTTP/1.0 200 OK
    Server: nginx/0.6.31
    Content-Language: ru
    Content-Type: text/html; charset=utf-8
    Content-Length: 1234
    Connection: close

    ... САМА HTML-СТРАНИЦА ...
    ```

    Methods:
    - GET — получение ресурса
    - POST — создание ресурса
    - PUT — обновление ресурса
    - DELETE — удаление ресурса
    - GET - Передача небольших текстовых данных на сервер; поиск по сайту. Поисковые системы, формы поиска по сайту всегда отправляются методом GET, это позволяет делиться результатами поиска с друзьями, слать ссылку по почте или выкладывать её на форуме.
    - POST. Пересылка файлов (фотографий, архивов, программ и др.); отправка комментариев; добавление и редактирование сообщений на форуме, блоге.
    - PATH - ????

 2. Из чего состоит URL
    - URI (/ˌjuː ɑːr ˈaɪ/ англ. Uniform Resource Identifier. URL — это URI, который, помимо идентификации ресурса, предоставляет ещё и информацию о местонахождении этого ресурса. А URN — это URI, который только идентифицирует ресурс в определённом пространстве имён (и, соответственно, в определённом контексте), но не указывает его местонахождения. Например, URN urn:ISBN:0-395-36341-1 — это URI, который указывает на ресурс (книгу) 0-395-36341-1 в пространстве имён ISBN, но, в отличие от URL, URN не указывает на местонахождение этого ресурса: в нём не сказано, в каком магазине её можно купить или на каком сайте скачать. Впрочем, в последнее время появилась тенденция говорить просто URI о любой строке-идентификаторе, без дальнейших уточнений. Так что, возможно, термины URL и URN скоро уйдут в прошлое. URI = [ схема ":" ] иерархическая-часть [ "?" запрос ] [ "#" фрагмент ]
    - Изначально локатор URL был разработан как система для максимально естественного указания на местонахождения ресурсов в сети. Локатор должен был быть легко расширяемым и использовать лишь ограниченный набор ASCII‐символов (к примеру, пробел никогда не применяется в URL). В связи с этим, возникла следующая традиционная форма записи URL:<схема>:[//[<логин>:<пароль>@]<хост>[:<порт>]][/]<URL‐путь>[?<параметры>][#<якорь>]
    В этой записи:
    - схема
    схема обращения к ресурсу; в большинстве случаев имеется в виду сетевой протокол
    - логин 
    имя пользователя, используемое для доступа к ресурсу
    - пароль 
    пароль указанного пользователя
    - хост 
    полностью прописанное доменное имя хоста в системе DNS или IP-адрес хоста в форме четырёх групп десятичных чисел, разделённых точками; числа — целые в интервале от 0 до 255.
    - порт 
    порт хоста для подключения
    - URL-путь 
    уточняющая информация о месте нахождения ресурса; зависит от протокола.
    - параметры 
    строка запроса с передаваемыми на сервер (методом GET) параметрами. Начинается с символа ?, разделитель параметров — знак &. Пример: ?параметр_1=значение_1&параметр_2=значение_2&параметр3=значение_3
    - якорь 
    идентификатор «якоря» (англ.)русск. с предшествующим символом #. Якорем может быть указан заголовок внутри документа или атрибут id (англ.)русск. элемента. По такой ссылке браузер откроет страницу и переместит окно к указанному элементу. Например, ссылка на этот раздел статьи: https://ru.wikipedia.org/wiki/URL#Структура_URL.



## Подготовка к созданию полноценного CLI

1. Написать короткий скрипт, который превращает аргументы коммандной строки в словарь. Напоминаю, что аргументы скриптом получаются через `sys.argv`. Пример: 

```
$ python args.py -t 10 --argument-name some_name -x -n hello
{
    't': '10',
    'argument_name': 'some_name',
    'x': True,
    'n': 'hello',
}
```

или 

```
$python args.py -key1 value1 -key2 value2 --key3 value3
{
    'key1': 'value1',
    'key2': 'value2',
    'key4': 'value3',
}
```

Идея такая: передаются аргументы в виде `-ключ значение`. Они попадают в словарь в виде: 

```python
{
    'ключ': 'значение'
}
```

**Некоторые условия:**
 1. У ключа обязательно в начале должно быть либо 1 либо 2 знака `-`, но в результирующий словарь эти минусы не должны попадать. 
 2. У значений ключей знаки `-` должны превращаться в `_`, т.е. `some-name` -> `some_name`
 3. Если у ключа нет значения, то в словаре у него значение будет True


 ##### Самостоятельное задание:

 1. Как работает обработка ошибок?
 2. Как работает функция format?
 3. Почитать про теги html
 4. Читать. Разъяснение http2, История, протокол, реализации и будущее